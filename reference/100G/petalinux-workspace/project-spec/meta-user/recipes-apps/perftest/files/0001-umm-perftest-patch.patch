From 12451fa12ead692554249d1f359ce5f524bd6f04 Mon Sep 17 00:00:00 2001
From: Anjaneyulu Reddy Mule <anjaneyulu.reddy.mule@xilinx.com>
Date: Mon, 24 Aug 2020 13:00:09 +0530
Subject: [PATCH] umm perftest patch

Signed-off-by: Anjaneyulu Reddy Mule <anjaneyulu.reddy.mule@xilinx.com>
---
 Makefile.am                  |   1 +
 src/perftest_communication.c |  18 ++++-
 src/perftest_resources.c     | 136 +++++++++++++++++++++++++++--------
 src/perftest_resources.h     |  15 +++-
 4 files changed, 138 insertions(+), 32 deletions(-)

diff --git a/Makefile.am b/Makefile.am
index 48a9bc3..7e607da 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -17,6 +17,7 @@ AUTOMAKE_OPTIONS= subdir-objects
 noinst_LIBRARIES = libperftest.a
 libperftest_a_SOURCES = src/get_clock.c src/perftest_communication.c src/perftest_parameters.c src/perftest_resources.c
 noinst_HEADERS = src/get_clock.h src/perftest_communication.h src/perftest_parameters.h src/perftest_resources.h
+libperftest_a_LIBADD = ./../../../umm/1.0-r0/libumm.so
 
 bin_PROGRAMS = ib_send_bw ib_send_lat ib_write_lat ib_write_bw ib_read_lat ib_read_bw ib_atomic_lat ib_atomic_bw
 bin_SCRIPTS = run_perftest_loopback
diff --git a/src/perftest_communication.c b/src/perftest_communication.c
index 5ae443c..f979e37 100755
--- a/src/perftest_communication.c
+++ b/src/perftest_communication.c
@@ -63,15 +63,22 @@ static int post_one_recv_wqe(struct pingpong_context *ctx)
 {
 	struct ibv_recv_wr wr;
 	struct ibv_recv_wr *bad_wr;
+#ifndef UMM_ALLOC
 	struct ibv_sge list;
 
 	list.addr   = (uintptr_t)ctx->buf[0];
 	list.length = sizeof(struct pingpong_dest);
 	list.lkey   = ctx->mr[0]->lkey;
+	wr.sg_list = list;
+#else
+	ctx->list.addr   = (uintptr_t)ctx->buf[0];
+	ctx->list.length = sizeof(struct pingpong_dest);
+	ctx->list.lkey   = ctx->mr[0]->lkey;
+	wr.sg_list = &ctx->list;
+#endif
 
 	wr.next = NULL;
 	wr.wr_id = SYNC_SPEC_ID;
-	wr.sg_list = &list;
 	wr.num_sge = 1;
 
 	if (ibv_post_recv(ctx->qp[0],&wr,&bad_wr)) {
@@ -414,7 +421,11 @@ static int rdma_read_keys(struct pingpong_dest *rem_dest,
 	}
 
 	#ifdef HAVE_ENDIAN
+	#ifdef UMM_ALLOC
+	memcpy(&a_rem_dest,comm->rdma_ctx->list.addr,sizeof(struct pingpong_dest));
+	#else
 	memcpy(&a_rem_dest,comm->rdma_ctx->buf[0],sizeof(struct pingpong_dest));
+	#endif
 	rem_dest->lid   = ntohl(a_rem_dest.lid);
 	rem_dest->out_reads     = ntohl(a_rem_dest.out_reads);
 	rem_dest->qpn   = ntohl(a_rem_dest.qpn);
@@ -1287,6 +1298,11 @@ int rdma_write_data(void *data,
 	int ne;
 	memcpy(comm->rdma_ctx->buf[0],data,size);
 
+#ifdef UMM_ALLOC
+	/*ERNIC supports minimum 16Bytes*/
+	if (size < 16)
+		size = 16;
+#endif
 	list.addr   = (uintptr_t)comm->rdma_ctx->buf[0];
 	list.length = size;
 	list.lkey   = comm->rdma_ctx->mr[0]->lkey;
diff --git a/src/perftest_resources.c b/src/perftest_resources.c
index f7d6e59..2dc0c8e 100755
--- a/src/perftest_resources.c
+++ b/src/perftest_resources.c
@@ -13,6 +13,9 @@
 
 #include "perftest_resources.h"
 #include "config.h"
+#ifdef UMM_ALLOC
+#include <umm_export.h>
+#endif
 
 #ifdef HAVE_VERBS_EXP
 static enum ibv_exp_wr_opcode exp_opcode_verbs_array[] = {IBV_EXP_WR_SEND,IBV_EXP_WR_RDMA_WRITE,IBV_EXP_WR_RDMA_READ};
@@ -583,6 +586,20 @@ int destroy_rdma_resources(struct pingpong_context *ctx,
 		struct perftest_parameters *user_param)
 {
 	int ret;
+#ifdef UMM_ALLOC
+	if (ctx->chunk_info.chunk_id) {
+		if (xib_umem_free_mem(ctx->cm_id->verbs, ctx->chunk_info.chunk_id,
+				(uint64_t)(uintptr_t)ctx->buf[0],
+				ctx->buff_size) < 0) {
+			printf("Failed to dealloc umm buf memory: %llx\n", ctx->buf[0]);
+		}
+		if (xib_umem_free_chunk(ctx->cm_id->verbs,
+				ctx->chunk_info.chunk_id) < 0) {
+			printf("Failed to deallocate chunk\n");
+		}
+		ctx->chunk_info.chunk_id = 0;
+	}
+#endif
 	if (user_param->machine == CLIENT) {
 		ret = rdma_destroy_id(ctx->cm_id);	
 	} else {
@@ -761,6 +778,17 @@ int destroy_ctx(struct pingpong_context *ctx,
 				return test_result;
 		} else
 		#endif
+#ifdef UMM_ALLOC
+		if (xib_umem_free_mem(ctx->cm_id->verbs, ctx->chunk_info.chunk_id,
+				(uint64_t)(uintptr_t)ctx->buf[i],
+				ctx->buff_size) < 0) {
+			printf("Failed to dealloc umm buf memory: %llx\n", ctx->buf[i]);
+		}
+		if (xib_umem_free_chunk(ctx->cm_id->verbs,
+						ctx->chunk_info.chunk_id) < 0) {
+                        printf("Failed to deallocate chunk\n");
+                }
+#endif
 		if (ibv_destroy_qp(ctx->qp[i])) {
 			fprintf(stderr, " Couldn't destroy QP - %s\n",strerror(errno));
 			test_result = 1;
@@ -863,7 +891,9 @@ int destroy_ctx(struct pingpong_context *ctx,
 		pp_free_mmap(ctx);
 	} else if (ctx->is_contig_supported == FAILURE) {
 		for (i = 0; i < dereg_counter; i++) {
+#ifndef UMM_ALLOC
 			free(ctx->buf[i]);
+#endif
 		}
 	}
 	free(ctx->qp);
@@ -1160,6 +1190,40 @@ int create_single_mr(struct pingpong_context *ctx, struct perftest_parameters *u
 	} else {
 		/* Allocating buffer for data, in case driver not support contig pages. */
 		if (ctx->is_contig_supported == FAILURE) {
+#ifdef UMM_ALLOC
+			uint64_t vaddr;
+
+			if(!ctx->chunk_info.chunk_id) {
+				ctx->chunk_info.chunk_id =  xib_umem_alloc_chunk(
+							ctx->cm_id->verbs, XMEM_PL_DDR,
+							ctx->buff_size,
+							ctx->buff_size, true);
+				if (ctx->chunk_info.chunk_id < 0) {
+					printf("Failed to alloc chunk\n");
+					return FAILURE;
+				}
+			}
+
+			vaddr =  xib_umem_alloc_mem(ctx->cm_id->verbs,
+						ctx->chunk_info.chunk_id,
+						ctx->buff_size);
+			if (!vaddr) {
+				printf("Failed to alloc mem of size 0x%x chunk_id 0x%x\n",
+						ctx->buff_size, ctx->chunk_info.chunk_id);
+				return -ENOMEM;
+			}
+			ctx->buf[qp_index] = (uintptr_t)vaddr;
+
+			{
+				unsigned int i = 0;
+				unsigned char *buf = vaddr;
+				for (i = 0; i < ctx->buff_size; i++) {
+					buf[i] = i;
+				}
+			}
+			/*BUS ERROR - while doing memset with umm allocated memory*/
+			//memset(ctx->buf[qp_index], 0, ctx->buff_size);
+#else
 			ctx->buf[qp_index] = memalign(user_param->cycle_buffer, ctx->buff_size);
 			if (!ctx->buf[qp_index]) {
 				fprintf(stderr, "Couldn't allocate work buf.\n");
@@ -1167,6 +1231,7 @@ int create_single_mr(struct pingpong_context *ctx, struct perftest_parameters *u
 			}
 
 			memset(ctx->buf[qp_index], 0, ctx->buff_size);
+#endif
 		} else {
 			ctx->buf[qp_index] = NULL;
 			#ifdef HAVE_VERBS_EXP
@@ -1220,6 +1285,9 @@ int create_single_mr(struct pingpong_context *ctx, struct perftest_parameters *u
 		fprintf(stderr, "Couldn't allocate MR\n");
 		return 1;
 	}
+#ifdef UMM_ALLOC
+	ctx->mr[qp_index]->lkey = ctx->chunk_info.chunk_id;
+#endif
 
 	if (ctx->is_contig_supported == SUCCESS)
 		ctx->buf[qp_index] = ctx->mr[qp_index]->addr;
@@ -1637,9 +1705,12 @@ struct ibv_qp* ctx_qp_create(struct pingpong_context *ctx,
 		attr.cap.max_recv_sge = 0;
 	} else {
 		attr.srq = NULL;
-		attr.cap.max_recv_wr  = user_param->rx_depth;
+		if (user_param->verb == SEND)
+			attr.cap.max_recv_wr  = user_param->rx_depth * 2;
+		else
+			attr.cap.max_recv_wr  = user_param->rx_depth;
 #if 1
-		attr.cap.max_recv_sge = user_param->size > 256? (user_param->size / 256): 1;
+		attr.cap.max_recv_sge = user_param->size > 256? ((user_param->size + 255) / 256): 1;
 #else
 		attr.cap.max_recv_sge = MAX_RECV_SGE;
 #endif
@@ -2994,44 +3065,49 @@ int run_iter_bw(struct pingpong_context *ctx,struct perftest_parameters *user_pa
 			else
 			#endif
 
-			ne = ibv_poll_cq(ctx->send_cq,CTX_POLL_BATCH,wc);
+			while (1) {
+				ne = ibv_poll_cq(ctx->send_cq, CTX_POLL_BATCH, wc);
 
-			if (ne > 0) {
-				for (i = 0; i < ne; i++) {
-					wc_id = (user_param->verb_type == ACCL_INTF) ?
-						0 : (int)wc[i].wr_id;
+				if (ne > 0) {
+					static unsigned int cqs_cnt = 0;
 
-					if (user_param->verb_type != ACCL_INTF) {
-						if (wc[i].status != IBV_WC_SUCCESS) {
-							NOTIFY_COMP_ERROR_SEND(wc[i],totscnt,totccnt);
-							return_value = 1;
-							goto cleaning;
+					for (i = 0; i < ne; i++) {
+						wc_id = (user_param->verb_type == ACCL_INTF) ?
+							0 : (int)wc[i].wr_id;
+
+						if (user_param->verb_type != ACCL_INTF) {
+							if (wc[i].status != IBV_WC_SUCCESS) {
+								NOTIFY_COMP_ERROR_SEND(wc[i],totscnt,totccnt);
+								return_value = 1;
+								goto cleaning;
+							}
 						}
-					}
 
-					ctx->ccnt[wc_id] += user_param->cq_mod;
-					totccnt += user_param->cq_mod;
+						ctx->ccnt[wc_id] += user_param->cq_mod;
+						totccnt += user_param->cq_mod;
 
-					if (user_param->noPeak == OFF) {
+						if (user_param->noPeak == OFF) {
 
-						if (totccnt >=  tot_iters - 1)
-							user_param->tcompleted[user_param->iters*num_of_qps - 1] = get_cycles();
-						else
-							user_param->tcompleted[totccnt-1] = get_cycles();
-					}
+							if (totccnt >=  tot_iters - 1)
+								user_param->tcompleted[user_param->iters*num_of_qps - 1] = get_cycles();
+							else
+								user_param->tcompleted[totccnt-1] = get_cycles();
+						}
 
-					if (user_param->test_type==DURATION && user_param->state == SAMPLE_STATE) {
-						if (user_param->report_per_port) {
-							user_param->iters_per_port[user_param->port_by_qp[wc_id]] += user_param->cq_mod;
+						if (user_param->test_type==DURATION && user_param->state == SAMPLE_STATE) {
+							if (user_param->report_per_port) {
+								user_param->iters_per_port[user_param->port_by_qp[wc_id]] += user_param->cq_mod;
+							}
+							user_param->iters += user_param->cq_mod;
 						}
-						user_param->iters += user_param->cq_mod;
 					}
-				}
+					break;
 
-			} else if (ne < 0) {
-				fprintf(stderr, "poll CQ failed %d\n",ne);
-				return_value = 1;
-				goto cleaning;
+				} else if (ne < 0) {
+					fprintf(stderr, "poll CQ failed %d\n",ne);
+					return_value = 1;
+					goto cleaning;
+				}
 			}
 		}
 	}
diff --git a/src/perftest_resources.h b/src/perftest_resources.h
index c5b6413..c7ab921 100755
--- a/src/perftest_resources.h
+++ b/src/perftest_resources.h
@@ -119,6 +119,16 @@
 
 #define MASK_IS_SET(mask, attr)      (((mask)&(attr))!=0)
 
+#define UMM_ALLOC
+#ifdef UMM_ALLOC
+struct umm_st {
+	unsigned int chunk_id;
+	struct ibv_context      *verbs;
+};
+
+extern struct umm_st umm;
+#endif
+
 /******************************************************************************
  * Perftest resources Structures and data types.
  ******************************************************************************/
@@ -175,7 +185,10 @@ struct pingpong_context {
 	struct ibv_exp_cq_family		*recv_cq_family;
 	struct ibv_exp_qp_burst_family		**qp_burst_family;
 	#endif
-
+	#ifdef UMM_ALLOC
+	struct ibv_sge				list;
+	struct umm_st				chunk_info;
+	#endif
 };
 
  struct pingpong_dest {
-- 
2.25.0

